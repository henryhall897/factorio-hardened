//go:build mage

package main

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/magefile/mage/mg"
)

// Build defines the namespace for building, scanning, and publishing
// the hardened Factorio images using verified digests from SrcDigest.
type Build mg.Namespace

const (
	imageRepo          = "ghcr.io/henryhall897/factorio-hardened"
	buildDataDir       = "builddata"
	baselineFile       = buildDataDir + "/baseline.yaml" // output from SrcDigest
	outputDockerfile   = "docker/output.Dockerfile"
	hardenedDockerfile = "docker/Dockerfile"
	localTestTag       = "factorio-hardened:dev"
)

// BuildMetadata stores internal build information.
type BuildMetadata struct {
	Version    string `json:"version"`
	BaseDigest string `json:"base_digest"`
	UpdatedAt  string `json:"updated_at"`
}

// --- helpers ---

// loadBaseline loads the upstream digest baseline generated by SrcDigest.Sync().
func loadBaseline() (*MultiArchMetadata, error) {
	data, err := os.ReadFile(baselineFile)
	if err != nil {
		return nil, fmt.Errorf("cannot read baseline file: %v", err)
	}
	var meta MultiArchMetadata
	if err := json.Unmarshal(data, &meta); err != nil {
		return nil, fmt.Errorf("failed to parse baseline.yaml: %v", err)
	}
	return &meta, nil
}

// getFactorioVersion extracts the Factorio version from baseline.yaml, labels,
// or by invoking the binary with --version in the container (safe for headless).
func getFactorioVersion(imageRef string) (string, error) {
	// 1ï¸âƒ£ Try from baseline.yaml
	if _, err := os.Stat(baselineFile); err == nil {
		data, err := os.ReadFile(baselineFile)
		if err == nil {
			var meta struct {
				Version string `json:"version,omitempty"`
				Tag     string `json:"tag,omitempty"`
			}
			if jsonErr := json.Unmarshal(data, &meta); jsonErr == nil {
				if strings.TrimSpace(meta.Version) != "" {
					fmt.Printf("ğŸ“˜ Using Factorio version from baseline: %s\n", meta.Version)
					return strings.TrimSpace(meta.Version), nil
				}
				if meta.Tag != "" && meta.Tag != "latest" {
					fmt.Printf("ğŸ“˜ Using Factorio tag from baseline: %s\n", meta.Tag)
					return meta.Tag, nil
				}
			}
		}
	}

	// 2ï¸âƒ£ Try from label
	cmd := exec.Command("docker", "inspect", "--format", "{{index .Config.Labels \"org.opencontainers.image.version\"}}", imageRef)
	out, err := cmd.CombinedOutput()
	if err == nil && strings.TrimSpace(string(out)) != "" {
		version := strings.TrimSpace(string(out))
		fmt.Printf("ğŸ“¦ Using Factorio version from image label: %s\n", version)
		return version, nil
	}

	// 3ï¸âƒ£ Fallback: run the binary directly with --version (headless-safe)
	fmt.Println("â„¹ï¸  Extracting Factorio version via binary output...")
	cmd = exec.Command("docker", "run", "--rm", "--entrypoint", "/opt/factorio/bin/x64/factorio", imageRef, "--version")
	out, err = cmd.CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("failed to extract Factorio version: %v\n%s", err, string(out))
	}

	// Parse output like: "Factorio 2.0.72 (build ...)"
	for _, f := range strings.Fields(string(out)) {
		if strings.Count(f, ".") == 2 && strings.HasPrefix(f, "2.") {
			return f, nil
		}
	}

	return "unknown", nil
}

// runCmd runs a command and prints its stdout/stderr inline.
func runCmd(name string, args ...string) error {
	cmd := exec.Command(name, args...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

// verifyKyverno runs kyverno CLI checks to confirm security policies are satisfied.
func verifyKyverno(image string) error {
	fmt.Println("ğŸ”’ Verifying Kyverno policy compliance...")
	// Example: using kyverno-cli verifyimage or policy reports
	return runCmd("kyverno", "verifyimage", image)
}

// ensureDirs creates the required builddata directory structure.
// It guarantees that builddata/, builddata/test/, and builddata/prod/ exist.
func ensureDirs() error {
	dirs := []string{
		buildDataDir,
		filepath.Join(buildDataDir, "test"),
		filepath.Join(buildDataDir, "prod"),
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", dir, err)
		}
	}
	return nil
}

// --- Targets ---

// Test builds a single-arch local image (amd64) for developer validation.
// It does not push to GHCR and intentionally avoids tagging with game version.
func (Build) Test() error {
	fmt.Println("ğŸ§ª Running Build:Test (local single-arch build)...")

	meta, err := loadBaseline()
	if err != nil {
		return fmt.Errorf("failed to load baseline: %w", err)
	}
	baseDigest := meta.Digests["amd64"]
	if baseDigest == "" {
		return fmt.Errorf("no amd64 digest found in baseline")
	}
	dockerfile := hardenedDockerfile
	if _, err := os.Stat(outputDockerfile); err == nil {
		dockerfile = outputDockerfile
	}

	// Step 1: Build local single-arch image
	if err := runCmd("docker", "buildx", "build",
		"--platform", "linux/amd64",
		"--file", dockerfile,
		"--build-arg", fmt.Sprintf("BASE_IMAGE_DIGEST=%s", baseDigest),
		"--no-cache",
		"--tag", localTestTag,
		"--load",
		".",
	); err != nil {
		return fmt.Errorf("local build failed: %v", err)
	}

	// Step 2: Run Trivy scan on *local* tag
	os.Setenv("IMAGE", localTestTag)
	if err := (Trivy{}.ImageScan)(); err != nil {
		return fmt.Errorf("Trivy scan failed: %v", err)
	}

	// Step 3: (Optional) Kyverno check
	if err := verifyKyverno(localTestTag); err != nil {
		fmt.Println("âš ï¸  Kyverno verification skipped or failed:", err)
	}

	// Step 4: (Optional) smoke test run
	fmt.Println("ğŸš€ Launching short Factorio container test...")
	_ = exec.Command("docker", "rm", "-f", "factorio-test").Run()
	run := exec.Command("docker", "run", "--rm", "--read-only",
		"--name", "factorio-test", localTestTag, "--version")
	run.Stdout = os.Stdout
	run.Stderr = os.Stderr
	_ = run.Run()

	// Step 5: Print image digest for verification
	fmt.Println("ğŸ” Inspecting built image digest...")
	inspectCmd := exec.Command("docker", "inspect", "--format", "{{index .RepoDigests 0}}", localTestTag)
	digestOut, err := inspectCmd.CombinedOutput()
	var imageDigest string

	if err != nil || len(strings.TrimSpace(string(digestOut))) == 0 {
		fmt.Println("â„¹ï¸  No RepoDigest found (image not pushed). Using local image ID instead...")
		idCmd := exec.Command("docker", "inspect", "--format", "{{.Id}}", localTestTag)
		idOut, idErr := idCmd.CombinedOutput()
		if idErr != nil {
			fmt.Printf("âš ï¸  Failed to retrieve local image ID: %v\n", idErr)
			imageDigest = "unknown"
		} else {
			imageDigest = strings.TrimSpace(string(idOut))
			fmt.Printf("ğŸ“¦ Local image ID: %s\n", imageDigest)
		}
	} else {
		imageDigest = strings.TrimSpace(string(digestOut))
		fmt.Printf("ğŸ“¦ Local image digest: %s\n", imageDigest)
	}

	// Step 6: Write metadata snapshot (always fresh)
	if err := ensureDirs(); err != nil {
		return err
	}

	buildDataPath := filepath.Join(buildDataDir, "test", "builddata.json")

	metaOut := map[string]any{
		"BaseDigest": baseDigest,
		"Arch":       "amd64",
		"Version":    "dev",
		"Tag":        localTestTag,
		"Digest":     imageDigest, // âœ… include digest
		"BuiltAt":    time.Now().UTC().Format(time.RFC3339Nano),
	}

	file, err := os.Create(buildDataPath)
	if err != nil {
		return fmt.Errorf("failed to write test builddata: %v", err)
	}
	defer file.Close()

	enc := json.NewEncoder(file)
	enc.SetIndent("", "  ")
	if err := enc.Encode(metaOut); err != nil {
		return fmt.Errorf("failed to encode metadata: %v", err)
	}

	fmt.Printf("ğŸ§¾ Test build metadata written â†’ %s\n", buildDataPath)
	fmt.Printf("ğŸ“¦ Digest recorded: %s\n", imageDigest)
	fmt.Println("âœ… Local test build and scan completed successfully.")

	return nil
}

// Prod performs a production-grade multi-arch build (amd64 + arm64),
// runs security scans and Kyverno verification, and pushes to GHCR.
func (Build) Prod() error {
	fmt.Println("ğŸ§± Running Build:Prod (multi-arch CI build)...")

	// Step 1: Load baseline (source of truth from SrcDigest)
	meta, err := loadBaseline()
	if err != nil {
		return err
	}
	baseDigest := meta.ManifestList
	if baseDigest == "" {
		return fmt.Errorf("no manifest list digest found in baseline")
	}

	// Step 2: Detect Factorio version from upstream image
	version, err := getFactorioVersion(upstreamImage)
	if err != nil {
		return fmt.Errorf("failed to detect Factorio version: %v", err)
	}
	tag := fmt.Sprintf("%s:%s", imageRepo, version)

	fmt.Printf("ğŸ® Detected Factorio version: %s\n", version)
	fmt.Printf("ğŸ“˜ Using upstream manifest list: %s\n", baseDigest)

	// Step 3: Build amd64 image locally for scanning
	dockerfilePath, err := filepath.Abs(hardenedDockerfile)
	if err != nil {
		return fmt.Errorf("failed to resolve Dockerfile path: %v", err)
	}
	if _, err := os.Stat(dockerfilePath); err != nil {
		return fmt.Errorf("Dockerfile not found at %s", dockerfilePath)
	}
	fmt.Printf("ğŸ“„ Using Dockerfile: %s\n", dockerfilePath)

	fmt.Println("ğŸ§© Building amd64 variant for vulnerability scan...")
	if err := runCmd("docker", "buildx", "build",
		"--builder", "hardened-builder",
		"--platform", "linux/amd64",
		"--file", dockerfilePath,
		"--build-arg", fmt.Sprintf("BASE_IMAGE_DIGEST=%s", baseDigest),
		"--tag", tag+"-amd64",
		"--load",
		".",
	); err != nil {
		return fmt.Errorf("amd64 prebuild failed: %v", err)
	}

	// Step 4: Run Trivy scan
	fmt.Println("ğŸ” Running Trivy vulnerability scan...")
	if err := runCmd("trivy", "image", "--severity", "HIGH,CRITICAL", "--exit-code", "1", tag+"-amd64"); err != nil {
		return fmt.Errorf("Trivy scan failed: %v", err)
	}

	// Step 5: Verify Kyverno compliance
	fmt.Println("ğŸ”’ Verifying Kyverno policy compliance...")
	if err := verifyKyverno(tag + "-amd64"); err != nil {
		fmt.Println("âš ï¸  Kyverno verification skipped or failed:", err)
	}

	// Step 6: Push multi-arch image to GHCR
	fmt.Println("ğŸš€ Building and pushing multi-arch image (amd64 + arm64)...")
	if err := runCmd("docker", "buildx", "build",
		"--no-cache",
		"--progress", "plain",
		"--platform", "linux/amd64,linux/arm64",
		"--file", hardenedDockerfile,
		"--build-arg", fmt.Sprintf("BASE_IMAGE_DIGEST=%s", baseDigest),
		"--tag", tag,
		"--push",
		".",
	); err != nil {
		return fmt.Errorf("multi-arch push failed: %v", err)
	}

	// Step 7: Inspect final GHCR digest
	fmt.Println("ğŸ” Inspecting pushed image digest...")
	inspectCmd := exec.Command("docker", "buildx", "imagetools", "inspect", tag, "--raw")
	digestOut, err := inspectCmd.CombinedOutput()

	var imageDigest string
	if err != nil {
		fmt.Printf("âš ï¸  Failed to inspect image digest: %v\n%s\n", err, string(digestOut))
		imageDigest = "unknown"
	} else {
		// Parse raw JSON and extract top-level manifest digest
		var manifest struct {
			SchemaVersion int    `json:"schemaVersion"`
			MediaType     string `json:"mediaType"`
			Config        struct {
				Digest string `json:"digest"`
			} `json:"config"`
			Manifests []struct {
				Digest string `json:"digest"`
			} `json:"manifests"`
		}
		if err := json.Unmarshal(digestOut, &manifest); err == nil {
			if len(manifest.Manifests) > 0 {
				imageDigest = strings.TrimSpace(manifest.Manifests[0].Digest)
			} else if manifest.Config.Digest != "" {
				imageDigest = strings.TrimSpace(manifest.Config.Digest)
			}
		}

		if imageDigest == "" {
			// fallback to regex (for Buildx log output)
			re := regexp.MustCompile(`sha256:[a-f0-9]{64}`)
			if m := re.FindString(string(digestOut)); m != "" {
				imageDigest = m
			}
		}

		if imageDigest == "" {
			imageDigest = "unknown"
			fmt.Println("âš ï¸  Could not parse image digest from output.")
		} else {
			fmt.Printf("ğŸ“¦ Multi-arch manifest digest: %s\n", imageDigest)
		}
	}

	// Step 8: Write metadata snapshot
	if err := ensureDirs(); err != nil {
		return err
	}

	buildDataPath := filepath.Join(buildDataDir, "prod", "builddata.json")
	metaOut := map[string]any{
		"BaseDigest": baseDigest,
		"Arch":       "multi-arch",
		"Version":    version,
		"Tag":        tag,
		"Digest":     imageDigest,
		"BuiltAt":    time.Now().UTC().Format(time.RFC3339Nano),
	}

	file, err := os.Create(buildDataPath)
	if err != nil {
		return fmt.Errorf("failed to write prod builddata: %v", err)
	}
	defer file.Close()

	enc := json.NewEncoder(file)
	enc.SetIndent("", "  ")
	if err := enc.Encode(metaOut); err != nil {
		return fmt.Errorf("failed to encode metadata: %v", err)
	}

	fmt.Printf("ğŸ§¾ Prod build metadata written â†’ %s\n", buildDataPath)
	fmt.Printf("ğŸ“¦ Digest recorded: %s\n", imageDigest)
	fmt.Printf("âœ… Multi-arch image %s pushed successfully.\n", tag)

	return nil
}
